<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìè Optimizador de Cortes</title>
    <style>
        :root { --p: #2563eb; --s: #10b981; --bg: #f8fafc; }
        body { font-family: system-ui, sans-serif; background: var(--bg); margin: 0; padding: 10px; }
        .card { background: white; padding: 15px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 10px; }
        input { width: 100%; padding: 12px; margin: 5px 0; border: 1px solid #cbd5e1; border-radius: 8px; box-sizing: border-box; font-size: 16px; }
        .piece-entry { background: #ffffff; padding: 12px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #e2e8f0; border-left: 6px solid var(--p); }
        .btn { border: none; border-radius: 8px; padding: 15px; color: white; font-weight: bold; width: 100%; margin-top: 10px; cursor: pointer; }
        .btn-add { background: var(--s); }
        .btn-calc { background: var(--p); font-size: 1.1rem; }
        .btn-del { background: #fee2e2; color: #ef4444; padding: 8px; border: none; border-radius: 6px; font-weight: bold; }
        .sheet-wrapper { background: white; padding: 15px; border-radius: 12px; margin-bottom: 25px; border: 1px solid #e2e8f0; }
        canvas { background: #fff; display: block; margin: 10px auto; max-width: 100%; height: auto; border: 1px solid #334155; }
        .stats { font-weight: bold; color: #1e40af; background: #dbeafe; padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; }
    </style>
</head>
<body>

    <div class="card">
        <h2 style="text-align:center;">Corte de M√°xima Eficiencia</h2>
        <label>Grosor de sierra (cm)</label>
        <input type="number" id="kerf" value="0.3" step="0.1" inputmode="decimal">
        
        <div id="piecesList" style="margin-top: 15px;">
            <div class="piece-entry">
                <input type="text" placeholder="Nombre" style="margin-bottom:8px">
                <div style="display:flex; gap:8px;">
                    <div style="flex:1"><label>Ancho</label><input type="number" class="w" value="120"></div>
                    <div style="flex:1"><label>Largo</label><input type="number" class="l" value="60"></div>
                    <div style="flex:1"><label>Cant.</label><input type="number" class="q" value="4"></div>
                </div>
                <button class="btn-del" onclick="this.parentElement.remove()">‚úï Quitar</button>
            </div>
        </div>

        <button class="btn btn-add" onclick="addRow()">+ A√±adir Medida</button>
        <button class="btn btn-calc" onclick="generate()">OPTIMIZAR AHORA</button>
    </div>

    <div id="results"></div>

<script>
    function addRow() {
        const div = document.createElement("div");
        div.className = "piece-entry";
        div.innerHTML = `<input type="text" placeholder="Nombre" style="margin-bottom:8px"><div style="display:flex; gap:8px;"><div style="flex:1"><input type="number" class="w"></div><div style="flex:1"><input type="number" class="l"></div><div style="flex:1"><input type="number" class="q"></div></div><button class="btn-del" onclick="this.parentElement.remove()">‚úï Quitar</button>`;
        document.getElementById("piecesList").appendChild(div);
    }

    function generate() {
        const res = document.getElementById("results");
        res.innerHTML = "";
        const kerf = parseFloat(document.getElementById("kerf").value) || 0;
        const SW = 122, SL = 244;
        const SCALE = (window.innerWidth - 50) / SW;

        let piecesToPlace = [];
        document.querySelectorAll(".piece-entry").forEach(el => {
            const w = parseFloat(el.querySelector(".w").value), l = parseFloat(el.querySelector(".l").value), q = parseInt(el.querySelector(".q").value);
            if(w && l && q) {
                const color = `hsl(${Math.random()*360}, 65%, 75%)`;
                for(let i=0; i<q; i++) piecesToPlace.push({ w, l, color });
            }
        });

        // 1. ORDENAMIENTO CR√çTICO: Por el lado m√°s largo primero
        piecesToPlace.sort((a,b) => Math.max(b.w, b.l) - Math.max(a.w, a.l));

        let sheetNum = 1;
        while(piecesToPlace.length > 0) {
            let placed = [];
            let freeRects = [{ x: 0, y: 0, w: SW, l: SL }];

            for (let i = 0; i < piecesToPlace.length; i++) {
                let p = piecesToPlace[i];
                let bestFit = null;
                let bestScore = Infinity;

                // 2. BUSCAR EN TODOS LOS ESPACIOS DISPONIBLES
                for (let j = 0; j < freeRects.length; j++) {
                    let fr = freeRects[j];
                    
                    // Probar ambas orientaciones
                    let orientations = [
                        { w: p.w, l: p.l },
                        { w: p.l, l: p.w }
                    ];

                    orientations.forEach(orient => {
                        if (orient.w <= fr.w && orient.l <= fr.l) {
                            // Puntuaci√≥n por "Short Side Fit" (mejor aprovechamiento de esquinas)
                            let score = Math.min(fr.w - orient.w, fr.l - orient.l);
                            if (score < bestScore) {
                                bestScore = score;
                                bestFit = { rectIdx: j, w: orient.w, l: orient.l };
                            }
                        }
                    });
                }

                if (bestFit) {
                    let fr = freeRects[bestFit.rectIdx];
                    placed.push({ x: fr.x, y: fr.y, w: bestFit.w, l: bestFit.l, color: p.color });

                    // 3. DIVIDIR EL ESPACIO (MaxRects mejorado)
                    let newRects = [];
                    // Espacio a la derecha
                    if (fr.w > bestFit.w) {
                        newRects.push({ x: fr.x + bestFit.w + kerf, y: fr.y, w: fr.w - bestFit.w - kerf, l: fr.l });
                    }
                    // Espacio abajo
                    if (fr.l > bestFit.l) {
                        newRects.push({ x: fr.x, y: fr.y + bestFit.l + kerf, w: bestFit.w, l: fr.l - bestFit.l - kerf });
                    }

                    freeRects.splice(bestFit.rectIdx, 1);
                    freeRects.push(...newRects);
                    
                    // Re-ordenar espacios libres para que los m√°s peque√±os se llenen primero
                    freeRects.sort((a, b) => (a.w * a.l) - (b.w * b.l));

                    piecesToPlace.splice(i, 1);
                    i--;
                }
            }
            render(placed, sheetNum++, SCALE, SW, SL, res);
        }
    }

    function render(pieces, num, sc, sw, sl, container) {
        const wrap = document.createElement("div");
        wrap.className = "sheet-wrapper";
        let used = pieces.reduce((a, b) => a + (b.w * b.l), 0);
        wrap.innerHTML = `<div style="display:flex;justify-content:space-between"><h3>Hoja ${num}</h3><span class="stats">Uso: ${((used/(sw*sl))*100).toFixed(1)}%</span></div>`;
        const canvas = document.createElement("canvas");
        canvas.width = sw * sc; canvas.height = sl * sc;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
        pieces.forEach(p => {
            ctx.fillStyle = p.color; ctx.fillRect(p.x*sc, p.y*sc, p.w*sc, p.l*sc);
            ctx.strokeStyle = "#000"; ctx.strokeRect(p.x*sc, p.y*sc, p.w*sc, p.l*sc);
            if(p.w*sc > 20) {
                ctx.fillStyle = "#000"; ctx.font = `bold ${Math.max(10, 3.5*sc)}px sans-serif`;
                ctx.fillText(`${p.w}x${p.l}`, (p.x+1)*sc, (p.y+5)*sc);
            }
        });
        wrap.appendChild(canvas);
        container.appendChild(wrap);
    }
</script>
</body>
</html>

